<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="https://github.com/joshua-wright" />
  <title>ECEN454 refsheet</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="data:text/css;charset=utf-8,%0Ahtml%20%7B%0Afont%2Dsize%3A%20125%25%3B%0Aoverflow%2Dy%3A%20scroll%3B%0A%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%2Dms%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%7D%0Abody%20%7B%0Acolor%3A%20%23444%3B%0Afont%2Dfamily%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%27Times%20New%20Roman%27%2C%20serif%3B%0Afont%2Dsize%3A%2012px%3B%0Aline%2Dheight%3A%201%2E7%3B%0Apadding%3A%201em%3B%0Amargin%3A%20auto%3B%0Amax%2Dwidth%3A%2050em%3B%0Abackground%3A%20%23fefefe%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230645ad%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%230b0080%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%2306e%3B%0A%7D%0Aa%3Aactive%20%7B%0Acolor%3A%20%23faa700%3B%0A%7D%0Aa%3Afocus%20%7B%0Aoutline%3A%20thin%20dotted%3B%0A%7D%0Ap%20%7B%0Amargin%3A%201em%200%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Acolor%3A%20%23111%3B%0Aline%2Dheight%3A%20125%25%3B%0Amargin%2Dtop%3A%202em%3B%0Amargin%2Dbottom%3A%200%2E125em%3B%0Afont%2Dweight%3A%20normal%3B%0A%7D%0Ah4%2C%20h5%2C%20h6%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Ah1%20%7B%0Afont%2Dsize%3A%202%2E5em%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%202em%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%201%2E5em%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ah6%20%7B%0Afont%2Dsize%3A%200%2E9em%3B%0A%7D%0Ablockquote%20%7B%0Acolor%3A%20%23666666%3B%0Amargin%3A%200%3B%0Apadding%2Dleft%3A%203em%3B%0Aborder%2Dleft%3A%200%2E5em%20%23EEE%20solid%3B%0A%7D%0Ahr%20%7B%0Adisplay%3A%20block%3B%0Aheight%3A%202px%3B%0Aborder%3A%200%3B%0Aborder%2Dtop%3A%201px%20solid%20%23aaa%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23eee%3B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%3B%0A%7D%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0Acolor%3A%20%23000%3B%0Afont%2Dfamily%3A%20monospace%2C%20monospace%3B%0A%5Ffont%2Dfamily%3A%20%27courier%20new%27%2C%20monospace%3B%0Afont%2Dsize%3A%200%2E98em%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%0Aword%2Dwrap%3A%20break%2Dword%3B%0A%7D%0Ab%2C%20strong%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adfn%20%7B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Ains%20%7B%0Abackground%3A%20%23ff9%3B%0Acolor%3A%20%23000%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Amark%20%7B%0Abackground%3A%20%23ff0%3B%0Acolor%3A%20%23000%3B%0Afont%2Dstyle%3A%20italic%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Asub%2C%20sup%20%7B%0Afont%2Dsize%3A%2075%25%3B%0Aline%2Dheight%3A%200%3B%0Aposition%3A%20relative%3B%0Avertical%2Dalign%3A%20baseline%3B%0A%7D%0Asup%20%7B%0Atop%3A%20%2D0%2E5em%3B%0A%7D%0Asub%20%7B%0Abottom%3A%20%2D0%2E25em%3B%0A%7D%0Aul%2C%20ol%20%7B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%200%200%202em%3B%0A%7D%0Ali%20p%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aul%20ul%2C%20ol%20ol%20%7B%0Amargin%3A%20%2E3em%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dbottom%3A%201em%3B%0A%7D%0Adt%20%7B%0Afont%2Dweight%3A%20bold%3B%0Amargin%2Dbottom%3A%20%2E8em%3B%0A%7D%0Add%20%7B%0Amargin%3A%200%200%20%2E8em%202em%3B%0A%7D%0Add%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aimg%20%7B%0Aborder%3A%200%3B%0A%2Dms%2Dinterpolation%2Dmode%3A%20bicubic%3B%0Avertical%2Dalign%3A%20middle%3B%0A%7D%0Afigure%20%7B%0Adisplay%3A%20block%3B%0Atext%2Dalign%3A%20center%3B%0Amargin%3A%201em%200%3B%0A%7D%0Afigure%20img%20%7B%0Aborder%3A%20none%3B%0Amargin%3A%200%20auto%3B%0A%7D%0Afigcaption%20%7B%0Afont%2Dsize%3A%200%2E8em%3B%0Afont%2Dstyle%3A%20italic%3B%0Amargin%3A%200%200%20%2E8em%3B%0A%7D%0Atable%20%7B%0Amargin%2Dbottom%3A%202em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dspacing%3A%200%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Abackground%2Dcolor%3A%20%23eee%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0Atable%20td%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0Avertical%2Dalign%3A%20top%3B%0A%7D%0A%2Eauthor%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20480px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2014px%3B%0A%7D%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20768px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2016px%3B%0A%7D%0A%7D%0A%40media%20print%20%7B%0A%2A%20%7B%0Abackground%3A%20transparent%20%21important%3B%0Acolor%3A%20black%20%21important%3B%0Afilter%3A%20none%20%21important%3B%0A%2Dms%2Dfilter%3A%20none%20%21important%3B%0A%7D%0Abody%20%7B%0Afont%2Dsize%3A%2012pt%3B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Aa%2C%20a%3Avisited%20%7B%0Atext%2Ddecoration%3A%20underline%3B%0A%7D%0Ahr%20%7B%0Aheight%3A%201px%3B%0Aborder%3A%200%3B%0Aborder%2Dbottom%3A%201px%20solid%20black%3B%0A%7D%0Aa%5Bhref%5D%3Aafter%20%7B%0Acontent%3A%20%22%20%28%22%20attr%28href%29%20%22%29%22%3B%0A%7D%0Aabbr%5Btitle%5D%3Aafter%20%7B%0Acontent%3A%20%22%20%28%22%20attr%28title%29%20%22%29%22%3B%0A%7D%0A%2Eir%20a%3Aafter%2C%20a%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2C%20a%5Bhref%5E%3D%22%23%22%5D%3Aafter%20%7B%0Acontent%3A%20%22%22%3B%0A%7D%0Apre%2C%20blockquote%20%7B%0Aborder%3A%201px%20solid%20%23999%3B%0Apadding%2Dright%3A%201em%3B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Atr%2C%20img%20%7B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%20%21important%3B%0A%7D%0A%40page%20%3Aleft%20%7B%0Amargin%3A%2015mm%2020mm%2015mm%2010mm%3B%0A%7D%0A%40page%20%3Aright%20%7B%0Amargin%3A%2015mm%2010mm%2015mm%2020mm%3B%0A%7D%0Ap%2C%20h2%2C%20h3%20%7B%0Aorphans%3A%203%3B%0Awidows%3A%203%3B%0A%7D%0Ah2%2C%20h3%20%7B%0Apage%2Dbreak%2Dafter%3A%20avoid%3B%0A%7D%0A%7D%0A" rel="stylesheet" type="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div id="header">
<h1 class="title">ECEN454 refsheet</h1>
<h2 class="author">https://github.com/joshua-wright</h2>
</div>
<h1 id="specifically-for-final">specifically for final</h1>
<ul>
<li>exam 1 was on March 8 (2017.03.08)</li>
<li>nothing specifically from previous exam</li>
</ul>
<h1 id="propagation-vs-contamination-delay">Propagation vs Contamination delay</h1>
<ul>
<li>contamination delay (<span class="math inline"><em>t</em><sub><em>c</em><em>d</em></sub></span>): time from input change to <strong>any</strong> output changing value</li>
<li>kind of a best-case delay or smallest possible delay</li>
<li>time counted when input crosses 50% of logical high voltage level</li>
<li>propagation delay: time from when all inputs are stable to when all outputs are stable</li>
<li>kind of like a worst-case delay</li>
</ul>
<h1 id="static-vs-dynamic-power">static vs dynamic power</h1>
<ul>
<li>static power
<ul>
<li>consumed when circuit is not active</li>
<li>e.g. leakage current</li>
<li>static because no inputs are changing</li>
</ul></li>
<li>dynamic power
<ul>
<li>power consumed due to gates switching and stuff</li>
<li>e.g. charging/discharging parasitic caps, etc...</li>
</ul></li>
</ul>
<h1 id="latch-vs-flip-flop">Latch vs Flip Flop</h1>
<ul>
<li>Latch is level-sensitive, flip-flop is edge-sensitive</li>
<li>register is flip-flop # Latch/flip flop designs</li>
<li>pass transistor latch
<ul>
<li>pros: tiny, low clock load</li>
<li>con: voltage drop across is <span class="math inline"><em>V</em><sub><em>t</em></sub></span>, it's non-restoring</li>
<li>con: not really a latch because doesn't hold signal</li>
</ul></li>
<li>transmission gate
<ul>
<li>pro: no <span class="math inline"><em>V</em><sub><em>t</em></sub></span> drop</li>
<li>con: requires inverted clock</li>
</ul></li>
<li>inverting buffer
<ul>
<li>TODO</li>
</ul></li>
<li>tristate feedback
<ul>
<li>first complete latch here</li>
<li>risk of backdriving: downstream could change state if it is very strong</li>
</ul></li>
<li>buffered output
<ul>
<li>no backdrifing problem</li>
<li>widely used</li>
<li>rather large and slow though, and large load on clock</li>
</ul></li>
<li>a flip-flop is just two latches back-to-back</li>
</ul>
<h1 id="metastability">Metastability</h1>
<ul>
<li>stable works if it's not at a strong high or low but will settle somewhere</li>
<li>metastable is where it might sit there, but if it must settle, you don't know which one it will settle to when perturbed</li>
</ul>
<h2 id="section">2017.03.27</h2>
<h1 id="sequential-circuits">Sequential Circuits</h1>
<ul>
<li>sequential means that the circuit holds state: the output depends on both current and past input</li>
<li>to model a state machine, you can unroll it to [register] <span class="math inline">→</span> [combinational] <span class="math inline">→</span> ...
<ul>
<li>this way you can use regular timing stuff for it: arrival time, slack, etc...</li>
</ul></li>
<li>Mealy FSM: output of circuit is from combinational logic</li>
<li>Moore FSM: output is from registers</li>
<li>pipelined circuit: uses registers to hold state between clock cycles, because not all of the combinational logic can happen fast enough to work in a single clock cycle
<ul>
<li>pipelined circuits can use flip-flops or latches?</li>
</ul></li>
<li>the clock consumes 20-30% of the power on a chip</li>
<li>the whole reason that registers are needed is because data (signals) moves through components at non-constant speed</li>
<li>reset
<ul>
<li>can be sync or async</li>
<li>force low output when reset is high</li>
</ul></li>
<li>sequencing: it is (generally) equivalent to split the sequential logic in two, and then use two latches (one halfway through) instead of one large section of sequential logic with flip-flops at either end
<ul>
<li>this is called two phase clocking</li>
<li>you have to make sure the middle latch operates on clock-bar instead of clock</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">symbol</th>
<th align="left">definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline"><em>t</em><sub><em>p</em><em>d</em></sub></span></td>
<td align="left">logic propagation delay</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline"><em>t</em><sub><em>c</em><em>d</em></sub></span></td>
<td align="left">logic contamination delay</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline"><em>t</em><sub><em>p</em><em>c</em><em>q</em></sub></span></td>
<td align="left">Clk<span class="math inline">→</span>Q propagation delay</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline"><em>t</em><sub><em>c</em><em>c</em><em>q</em></sub></span></td>
<td align="left">Clk<span class="math inline">→</span>Q contamination delay</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline"><em>t</em><sub><em>p</em><em>d</em><em>q</em></sub></span></td>
<td align="left">D<span class="math inline">→</span>Q propagation delay</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline"><em>t</em><sub><em>s</em><em>e</em><em>t</em><em>u</em><em>p</em></sub></span></td>
<td align="left">setup time of flip-flop/latch</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline"><em>t</em><sub><em>h</em><em>o</em><em>l</em><em>d</em></sub></span></td>
<td align="left">hold time of flip-flop/latch</td>
</tr>
</tbody>
</table>
<ul>
<li>timing:
<ul>
<li>D<span class="math inline">→</span>Q delay only makes sense for latches, since for flip-flops it is simply one clock cycle</li>
</ul></li>
<li>sequencing overhead and max delay:
<ul>
<li><span class="math inline"><em>T</em><sub><em>c</em></sub></span>: cycle time</li>
<li>need for combinational logic to be fast enough</li>
<li>for single phase flip flop: <span class="math inline"><em>t</em><sub><em>p</em><em>d</em></sub> &lt; <em>T</em><sub><em>c</em></sub> − (<em>T</em><sub><em>s</em><em>e</em><em>t</em><em>u</em><em>p</em></sub> + <em>T</em><sub><em>p</em><em>c</em><em>q</em></sub>)</span></li>
<li>for two-phase latch: <span class="math inline"><em>t</em><sub><em>p</em><em>d</em></sub> = <em>t</em><sub><em>p</em><em>d</em>1</sub> + <em>t</em><sub><em>p</em><em>d</em>2</sub> &lt; <em>T</em><sub><em>c</em></sub> − 2<em>t</em><sub><em>p</em><em>d</em><em>q</em></sub></span></li>
<li>max delay is dictated by cycle time and sequencing overhead; sequencing overhead does not effect minimum delay</li>
</ul></li>
<li>minimum delay:
<ul>
<li>for single phase flip flop: <span class="math inline"><em>t</em><sub><em>c</em><em>d</em></sub> &gt; <em>t</em><sub><em>h</em><em>o</em><em>l</em><em>d</em></sub> − <em>t</em><sub><em>c</em><em>c</em><em>q</em></sub></span>
<ul>
<li>combinational stuff must be slow enough that it doesn't violate hold time of second flip flop</li>
</ul></li>
<li>for two-phase latch: <span class="math inline"><em>t</em><sub><em>c</em><em>d</em>1</sub>, <em>t</em><sub><em>c</em><em>d</em>2</sub> &gt; <em>t</em><sub><em>h</em><em>o</em><em>l</em><em>d</em></sub> − <em>t</em><sub><em>c</em><em>c</em><em>q</em></sub> − <em>t</em><sub><em>n</em><em>o</em><em>n</em> − <em>o</em><em>v</em><em>e</em><em>r</em><em>l</em><em>a</em><em>p</em></sub></span>
<ul>
<li>hold time applies twice each cycle, once per each combinational circuit</li>
<li><span class="math inline"><em>t</em><sub><em>n</em><em>o</em><em>n</em> − <em>o</em><em>v</em><em>e</em><em>r</em><em>l</em><em>a</em><em>p</em></sub></span>: phase between clock signals?</li>
</ul></li>
</ul></li>
<li>time borrowing: for two-phase latch-based system, you can borrow time from one segment to the other while the latch is transparent
<ul>
<li>works (is possible) as long as the total circuit still completes within one clock cycle</li>
</ul></li>
<li>clock skew:
<ul>
<li>when uncertain: causes tighter required CL propagation delay and minimum CL contamination delay, and reduces opportunity for time borrowing.</li>
<li>when know constant skew: can help with same effect as time borrowing, except can also have effect for flip-flop based systems</li>
</ul></li>
<li>skew tolerance:
<ul>
<li>flip-flop circuits are not very skew tolerant because the setup and hold times define a specific window of time in which the data must arrive</li>
<li>latch circuits are more hold-time-tolerant because the data can arrive any time that the latch is transparent</li>
</ul></li>
<li>if setup times are violated, you can reduce clock speed to fix it</li>
<li>if hold times are violated, it won't work at any clock speed</li>
</ul>
<h2 id="section-1">2017.03.29</h2>
<h1 id="clocking">Clocking</h1>
<ul>
<li>H-Tree (clock distribution network)
<ul>
<li>laid out in such a way that the delay from the center to any leaf node is equal</li>
</ul></li>
<li>Grid clock distribution
<ul>
<li>grid on two or more levels</li>
<li>ensures low local skew, but there could still be larger chip-wide skew</li>
</ul></li>
<li>generally, the longer the delay between two point, the larger the worst-case clock skew</li>
<li>Domino circuit: TODO
<ul>
<li>a kind of dynamic logic</li>
<li>when the clock pulse cascades through the circuit, activating the pMOS at each stage?</li>
</ul></li>
</ul>
<h2 id="more">2017.04.03 (+more)</h2>
<h1 id="memory">Memory</h1>
<ul>
<li>random access or sequential access, or content addressable</li>
<li>CAM: content-addressable memory
<ul>
<li>basically like an associative array, or database</li>
<li>designed to search all memory at once in a single operation (wikipedia)</li>
<li>used in caches</li>
</ul></li>
<li>SRAM:
<ul>
<li>12T and 6T cell designs</li>
<li>12T design: just a latch connected to a bitline
<ul>
<li>boring and impractical because it's too large</li>
</ul></li>
<li>6T design: cross-coupled inverters (3T each) +2T for bit and bit-bar lines
<ul>
<li>we focus on 6T design</li>
</ul></li>
<li>read: pre-charge bit and bit-bar, raise wordline, read result
<ul>
<li>(need to pre-charge or else read is destructive?)</li>
<li>need sense amplifiers at the end of the bitlines because the signal will be weak, and the parasitic capacitance of the bitline depends on how many cells are 0 or 1</li>
</ul></li>
<li>write: drive data onto bit and bit-bar and raise wordline to write</li>
<li>cross coupled inverters must be much larger than the bitline transistors so that it doesn't flip while reading</li>
<li>per each column, you need:
<ul>
<li>piece of decoder</li>
<li>bitline sense amplifier</li>
<li>column multiplexer</li>
</ul></li>
<li>multi-port: means you can read from and write to the same cell in the same clock cycle and it works
<ul>
<li>implement by having multiple sequential read/write per cycle?</li>
</ul></li>
</ul></li>
<li>decoders:
<ul>
<li>must be pitch-matched to SRAM cell width for layout efficiency/simplicity (requires very skinny gates)</li>
<li>large (<span class="math inline"><em>n</em> &gt; 4</span>) decoders are inefficient, thus it is often helpful to use predecoding: factor out common gates into a second stage of decoders.
<ul>
<li>smaller area as alternative, but same logical effort (since same number of gates traversed)</li>
</ul></li>
</ul></li>
<li>twisted bitlines: bitlines are long and right next to each other, so there will be significant crosstalk and parasitic cap
<ul>
<li>solution: swap adjacent bit and bit-bar lines occasionally</li>
<li>reduces Miller factor (MCF)</li>
</ul></li>
<li>DRAM:
<ul>
<li>one transistor and one capacitor
<ul>
<li>transistor gates capacitor</li>
</ul></li>
<li>no charge is 0, charge is 1</li>
<li>open transistor to read/write</li>
<li>read is destructive</li>
<li>must be refreshed periodically due to leakage
<ul>
<li>thus, it's always consuming power</li>
</ul></li>
</ul></li>
<li>shift register:
<ul>
<li>can be implemented with cascade of flip-flops
<ul>
<li>can lead to hold time violations because no delay from clock to next data line? (TODO what? how?)</li>
<li>not very dense</li>
</ul></li>
<li>store data in SRAM and store begin/end pointers
<ul>
<li>more dense than individual flip-flops</li>
</ul></li>
</ul></li>
<li>Tapped Delay Line
<ul>
<li>shift register with programmable number of stages</li>
<li>implement using sequence of flip-flops, each with a bypass MUX from data in to out</li>
</ul></li>
<li>Queues: are a thing (TODO)</li>
<li>ROM: Read Only Memory:
<ul>
<li>mask-programmed ROMs are one transistor per bit</li>
</ul></li>
<li>PROMs, EPROMS, etc
<ul>
<li>generally burn out specific fuses to program ROM</li>
<li>E for erasable</li>
</ul></li>
</ul>
<h2 id="section-2">2017.04.10, 2017.04.12</h2>
<h1 id="low-power-design">Low Power Design</h1>
<ul>
<li>not so important when running from a battery since batteries store energy, not power</li>
<li>peak power
<ul>
<li>determines power/ground wiring and packaging limits</li>
<li>impacts signal/noise ratio</li>
</ul></li>
<li>reduce dynamic power: (AKA active power)
<ul>
<li>use smaller transistors</li>
<li>clock gating</li>
<li>reduce <span class="math inline"><em>V</em><sub><em>D</em><em>D</em></sub></span></li>
<li>reduce frequency
<ul>
<li>but be careful because that will make the computations take longer</li>
</ul></li>
</ul></li>
<li>reduce static power
<ul>
<li>power gating</li>
<li>selectively use lower <span class="math inline"><em>V</em><sub><em>t</em></sub></span> devices</li>
<li>stacked devices</li>
<li>body bias</li>
</ul></li>
<li>clock gating: disable the clock signal to an expensive component
<ul>
<li>eliminates that component's dynamic power (but of course you can't use it)</li>
<li>doesn't change static power</li>
</ul></li>
<li>voltage islands: different <span class="math inline"><em>V</em><sub><em>t</em></sub></span> for different devices
<ul>
<li>allow low <span class="math inline"><em>V</em><sub><em>t</em></sub></span> devices to run slower because they don't need to be fast (maybe they're not in the critical path)</li>
<li>often different voltage levels are alternated row by row in standard-cell layouts</li>
<li>you must convert from one logic level to another, because high/low will be different
<ul>
<li>sometimes it's possible to avoid conversion, e.g. by using a buffer that you would have anyway, with inverters built from half high-<span class="math inline"><em>V</em><sub><em>t</em></sub></span> transistors and half low-<span class="math inline"><em>V</em><sub><em>t</em></sub></span> transistors</li>
</ul></li>
<li>there are all kinds of tricks for determining which components should be high/low voltage and where to put voltage islands and level converters</li>
</ul></li>
<li>DFVS: Dynamic Frequency and Voltage Scaling
<ul>
<li>requires:
<ul>
<li>programmable clock generator (PLL)</li>
<li>supply regulation loop to for setting minimum <span class="math inline"><em>V</em><sub><em>D</em><em>D</em></sub></span></li>
<li>software support for deciding best stable frequency and voltage for given load and performance goals</li>
</ul></li>
<li>voltage regulation loop
<ul>
<li>voltage divider would be horribly inefficient</li>
<li>instead, rapidly charge/discharge capacitor</li>
</ul></li>
</ul></li>
<li>stacked devices:
<ul>
<li>stacking devices reduces leakage</li>
<li>because leakage is exponentially proportional to <span class="math inline"><em>V</em><sub><em>d</em><em>s</em></sub></span></li>
</ul></li>
<li>body bias AKA dual <span class="math inline"><em>V</em><sub><em>t</em></sub></span>
<ul>
<li>changing <span class="math inline"><em>V</em><sub><em>t</em></sub></span> at runtime is called Adaptive Body-Biasing (ABB) or Dynamic Threshold Scaling (DTS)
<ul>
<li>requires triple well fabrication process, because what would have been lowest level substrate must itself sit inside a well that will be biased</li>
</ul></li>
<li>design with low and high <span class="math inline"><em>V</em><sub><em>t</em></sub></span></li>
<li>low <span class="math inline"><em>V</em><sub><em>t</em></sub></span> is faster than high <span class="math inline"><em>V</em><sub><em>t</em></sub></span> but consumes 10x more power
<ul>
<li>because reducing <span class="math inline"><em>V</em><sub><em>t</em></sub></span> increases sub-threshold leakage exponentially</li>
<li>but reducing <span class="math inline"><em>V</em><sub><em>t</em></sub></span> decreases gate delay (increasing performance)</li>
</ul></li>
<li>to increase <span class="math inline"><em>V</em><sub><em>t</em></sub></span>, put a negative bias on <span class="math inline"><em>V</em><sub><em>S</em><em>B</em></sub></span> of nMOS
<ul>
<li>use DC charge pump to get desired voltage</li>
</ul></li>
</ul></li>
<li>power gating: use sleep transistors
<ul>
<li>basically cut off <span class="math inline"><em>V</em><sub><em>D</em><em>D</em></sub></span> from power-hungry circuits when not in use</li>
<li>in sleep mode, the sleeping transistors are stacked with the transistors that are causing them to sleep, thus reducing leakage even more</li>
</ul></li>
<li>MTCMOS sleep transistors
<ul>
<li>combines power gating and dual <span class="math inline"><em>V</em><sub><em>t</em></sub></span></li>
<li>TODO what is this?</li>
</ul></li>
</ul>
<h2 id="section-3">2017.04.26</h2>
<h1 id="testing">Testing</h1>
</body>
</html>
