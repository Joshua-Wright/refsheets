% # (c) Copyright 2017 Josh Wright
\documentclass{article}
\usepackage{mathrsfs,amsmath,amsthm,latexsym,paralist}
\usepackage{mathtools} 
\usepackage{bm} 
\usepackage{listings}
\usepackage{amssymb}   % for \varnothing, \therefore
\usepackage{centernot} % for \centernot
\usepackage{geometry}  % for margins
\usepackage{outlines}  % for outline
\usepackage{paralist}  % for compactitem, compactenum
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{minted}
\usepackage{hyperref}
\hypersetup{
  pdftitle={CSCE 314 Reference Sheet},
  pdfauthor={Josh Wright},
  pdfsubject={CSCE 314},
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=1,
  colorlinks=true,
  pdfstartview=Fit,
  pdfpagemode=UseOutlines,
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,      
  urlcolor=cyan,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% paper size, orientation, margins %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % good for on screen-only viewing
% \def \columncount {2}
% \geometry{letterpaper, landscape, margin=0.25in}
% good for printing
\def \columncount {2}
\geometry{letterpaper, portrait, margin=0.125in}


% makes second-level itemize bullets instead of dashes
% \renewcommand\labelitemi{\cdot}
\renewcommand\labelitemi{\hspace{-1in}\tiny$\bullet$}
\renewcommand\labelitemii{\labelitemi}

\newcommand{\java}{\mintinline{java}}
\newcommand{\haskell}{\mintinline{haskell}}

\newcommand{\p}{\partial}
\newcommand{\ang}[1]{\left\langle #1 \right\rangle}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\prt}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\grad}{\nabla}
\newcommand{\vrt}[1]{\rotatebox{90}{#1}}
\newcommand{\vrta}[2]{\rotatebox{90}{#1} \rotatebox{90}{#2}}
\newcommand{\vrtb}[3]{\rotatebox{90}{#1} \rotatebox{90}{#2} \rotatebox{90}{#3}}
\newcommand{\vrtc}[4]{\rotatebox{90}{#1} \rotatebox{90}{#2} \rotatebox{90}{#3} \rotatebox{90}{#4}}

\newcommand{\remove}[1]{}
% \newcommand{\remove}[1]{#1}

\newcommand{\tabletextsize}{\large}


% \setlength{\parindent}{0em}
% \setdefaultleftmargin{0em}{0em}{}{}


% super-dense mode:
% \renewcommand{\1}{\upspace $\bullet$\hspace{-0.5em} }
% \renewcommand{\2}{\upspace $\bullet\bullet$\hspace{-0.5em} }
% \renewcommand{\3}{\upspace $\bullet\bullet\bullet$\hspace{-0.5em} }
% \renewcommand{\4}{\upspace $\bullet\bullet\bullet\bullet$\hspace{-0.5em} }

% \newcommand{\zzz}[1]{{\noindent\textbf{#1:}}}
% \renewcommand{\1}{$\bullet$}
% \renewcommand{\2}{$\bullet$}
% \renewcommand{\3}{$\bullet$}
% \renewcommand{\4}{$\bullet$}


\begin{document}
\allowdisplaybreaks
% asterisk makes multicols finish one column before going onto the next
\begin{multicols}{\columncount}
\setlength{\columnseprule}{0.2pt}
\newlist{longenum}{itemize}{5}
\setlist[longenum,1]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\bullet$}
\setlist[longenum,2]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\ast$}
\setlist[longenum,3]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=-}
\setlist[longenum,4]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=>}
\setlist[longenum,5]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=@}
\begin{outline}[longenum]

\AtBeginEnvironment{minted}{ \fontsize{9}{9}\selectfont }
\newcommand{\upspace}{\vspace{-0.8px}\linespread{0}}
% section titles
% makes second-level itemize bullets instead of dashes
\renewcommand\labelitemii{\labelitemi}
% redefine the sub-headings to inject our space-saver
\let\oldOne\1\let\oldTwo\2\let\oldThree\3\let\oldFour\4
\newcommand{\zzz}[1]{\noindent\0\noindent {\textbf{#1:}} \upspace}
\renewcommand{\1}{\upspace \oldOne   \hspace{-6px}}
\renewcommand{\2}{\upspace \oldTwo   \hspace{-6px}}
\renewcommand{\3}{\upspace \oldThree \hspace{-6px}}
\renewcommand{\4}{\upspace \oldFour  \hspace{-6px}}

\noindent
\textbf{CSCE 314 Reference Sheet} \hfill Last Updated: \today \hfill \textcopyright \space Josh Wright 2017
% \vspace{-0.4cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% real content starts here %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\zzz{General}
  \1 \texttt{newtype Parser a = P (String -> [(a,String)])}
  \1 Predicate: a function that takes one argument and returns a boolean
    \2 if \texttt{pred x == True} then \texttt{x} satisfies predicate \texttt{pred}
  \1 function composition:
\begin{minted}[breaklines]{haskell}
-- the . operator composes functions:
(f . g) x == f (g x)
\end{minted}

\0 useful library functions:
\begin{minted}[breaklines]{haskell}
-- Data.List
nubBy :: (a -> a -> Bool) -> [a] -> [a]
nubBy pred xs = -- unique elements only from xs as 
                -- determined by pred
nub :: Eq a => [a] -> [a]
nub xs = nubBy (==) a -- unique elements from xs
-- 
words :: String -> [String]
words xs =  -- list of whitespace-separated 
            -- words from xs
--
-- concatenate container of lists
concat :: Foldable t => t [a] -> [a]
-- or for list-of-lists specifically:
concat :: [[a]] -> [a]
concat xs = foldl (++) [] xs
--
-- like concat, but use a function to get the inner lists
concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f xs =  foldr ((++) . f) [] xs
-- 
-- get the longest prefix of xs for which pred is true and also return the rest of the list
span :: (a -> Bool) -> [a] -> ([a], [a])
span pred xs = (takeWhile pred xs, dropWhile pred xs)
-- 
-- repeat a = infinite list of a
repeat :: a -> [a]
repeat x = map (\_ -> x) [1..]
repeat x = [ x | _ <- [1..] ]
-- replicate n a = list of length n repeating a
replicate :: Int -> a -> [a]
replicate n x = map (\_ -> x) [1..n]
replicate n x = [ x | _ <- [1..n] ]
--
-- folds (works on any foldable, not just lists)
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z [a,b,c] = a `f` (b `f`  (c `f` z))
foldr f z [a,b,c] = f a $ f b $ f c z
-- combines into z from right to left
-- can potentially work on an empty list if one of the folds does not evaluate it's second argument
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z [a,b,c] = ((z `f` a) `f` b) `f` c
foldl f z [a,b,c] = f (f (f z a) b) c
-- evaluates from right to left
-- will not work on infinite list because it must start at the end of the list
-- 
-- these are the same as above, except they take the first two elements for the first application of f
foldr1 :: (a -> a -> a) -> [a] -> a
foldl1 :: (a -> a -> a) -> [a] -> a
= \end{minted}


\zzz{Parsing.hs}
  \1 \texttt{sat :: (Char -> Bool) -> Parser Char}
    \2 returns a character if that character satisfies the predicate
  \1 \texttt{digit, letter, alphanum :: Parser Char}
    \2 parses a digit, letter, or alpha-numeric letter respectively
  \1 \texttt{char :: Char -> Parser Char}
    \2 \texttt{char `a'} parses exactly the character \texttt{`a'}
  \1 \texttt{item :: Parser Char}
    \2 parses any character
  \1 similar to above:
    \texttt{
      digit
      letter
      alphanum
      lower
      upper
      string
    }
  \1 \texttt{many :: Parser a -> Parser [a]}
    \2 parses 0 or more instances of \texttt{a} and collects them into a list
  \1 \texttt{many1 :: Parser a -> Parser [a]}
    \2 same as \texttt{many}, but 
  \1 \texttt{(+++)} choice: 
    \2 parse first argument if possible, else parse second argument
    \2 first successfully parsed argument is returned
\begin{minted}[breaklines]{haskell}
(+++) :: Parser a -> Parser a -> Parser a
p +++ q =  P (\inp -> case parse p inp of
                  []        -> parse q inp
                  [(v,out)] -> [(v,out)])
\end{minted}
  \1 \texttt{((>>=))} sequential composition
    \2 \texttt{a >>= b} unboxes monad \texttt{a} into an output \texttt{a0} and then unboxes monad \texttt{b} with input \texttt{a0}
\begin{minted}[breaklines]{haskell}
type Parser a = String -> [(a, String)]
-- implementation for in-class mostly-complete parser `monads'
(>>=) :: Parser a -> (a -> Parser b) -> Parser b
(>>=) p1 p2 = \inp -> case parse p1 inp of
      []  ->  []
      [(v, out)] -> parse (p2 v) out
= \end{minted} 
% for some reason, that equals sign needs to be there for my editor's syntax 
% hilightint to work

  \2 usage:
\begin{minted}[breaklines]{haskell}
doubleDigit :: Parser [Char]
doubleDigit =
  digit >>= \a ->
  digit >>= \b ->
  return [a,b]
-- is equivalent to
doubleDigit' :: Parser [Char]
doubleDigit' = do
  a <- digit
  b <- digit
  return [a,b]
\end{minted}
  \2 \texttt{(>>)} is the same except that it discards the result of the first monad (thus it has signature \texttt{(>>) :: Parser a -> Parser b -> Parser b})

\zzz{Parsing Examples}
  \1 bind and lambda method of parsing:
    \2 parse a number:
  \1 parse arithmetic expressions using do syntax:
\begin{minted}[breaklines]{haskell}
expr :: Parser Int
expr  = do t <- term
           do {char '+'
              ;e <- expr
              ;return (t + e)
              }
            +++ return t

term :: Parser Int
term  = do f <- factor
           do char '*'
              t <- term
              return (f * t)
            +++ return f

factor :: Parser Int
factor  = do d <- digit
             return (digitToInt d)
           +++ do char '('
                  e <- expr
                  char ')'
                  return e

eval   :: String -> Int
eval xs = fst (head (parse expr xs))
\end{minted}

\zzz{Trees}
  \1 represent either a leaf node or some kind of internal node
  \1 arithmetic tree declaration:
\begin{minted}[breaklines]{haskell}
data Expr = Val Int
          | Neg Expr 
          | Add Expr Expr 
          | Mul Expr Expr
\end{minted}
  \1 how to fold over a tree:
\begin{minted}[breaklines]{haskell}
-- exprFold  valF        negF      addF     
exprFold :: (Int->b) -> (b->b) -> (b->b->b) ->
-- mulF        input   output
  (b->b->b) -> Expr -> b
exprFold valF _ _ _ (Val i) = valF i
exprFold valF negF addF mulF (Neg e) 
  = negF  (exprFold valF negF addF mulF e)
exprFold valF negF addF mulF (Add s1 s2) 
  = addF  (exprFold valF negF addF mulF s1)
          (exprFold valF negF addF mulF s2)
exprFold valF negF addF mulF (Mul s1 s2) 
  = mulF  (exprFold valF negF addF mulF s1) 
          (exprFold valF negF addF mulF s2)
\end{minted}
    \2 basically, just collect values into some type \texttt{b} and use supplied functions at each node to fold into single value
    \2 useful for evaluating simple things like:
\begin{minted}[breaklines]{haskell}
-- evaluate an expression
evalExpr'    = exprFold id (\x -> 0 - x) (+) (*)
id --  integers map to integers
(\x -> 0 - x) -- negation
-- everything else is just simple numeric operators
-- 
-- count leaves in a tree
countLeaves' = exprFold (\_ -> 1) id (+) (+)
(\_ -> 1) -- leaf integer node is one node
id -- negation node has only one child, pass on count
(+) (+) -- nodes with two children: add number of leaf grandchildren
\end{minted}


\zzz{HW2: Water Gates}
\begin{minted}[breaklines]{haskell}


waterGate :: Int -> Int
waterGate n =
 length -- number of True's
 $ filter id -- filter just True's
 $ waterGate' n initial -- initial call to helper
 where
  -- start with all gates closed
  initial = replicate n False
  --
  -- flip states
  waterGate' 1 state = map not state 
    -- base case: flip every state
  waterGate' n state = flip n $ waterGate' (n-1) state
  -- otherwise, first get the state for (n-1) and then flip every nth state
  --
  -- flip every nth gate
  flip :: Int -> [Bool] -> [Bool]
  flip 1 xs = map not xs -- flip every gate
  -- flip only gates which index are multiples of n
  flip nth xs = [ if (i `mod` nth == 0) then not x else x
                -- zip each state with it's index
                | (x,i) <- (zip xs [1..])  ]

\end{minted}

\zzz{HW2: Goldbach's Other Conjecture}
\begin{minted}[breaklines]{haskell}
-- check if a number is prime
primeTest :: Integer -> Bool
primeTest 1 = False
primeTest t =  and [ (gcd t i) == 1 | i <- [2..t-1]]

-- all numbers less than n that are double a square
twiceSquares :: Integer -> [Integer]
twiceSquares n = takeWhile (<n) [ 2 *x^2 | x <- [1..]]

-- list of odd numbers
oddList = map (\x -> 2*x + 1) [0..]
-- all odd numbers that are composite (not prime)
allOddComp = [ o | o <- (drop 1 oddList)
                 , not (primeTest o)     ]

-- if a number satisfies conditions for conjecture
-- method: for enough square nubmers, check if n-(that number) is prime
satsConds n = or [ primeTest k | 
                  k <- map (\x->(n-x)) (twiceSquares n) ]

-- find the first number 
goldbachNum = head [ x | x <- allOddComp
                       , not (satsConds x) ]
\end{minted}


\zzz{HW4: Sets}
\begin{minted}[breaklines]{haskell}
type Set a = [a]

a = mkSet [1,2,3,4,5]
b = mkSet [1,2,3]


addToSet :: Eq a => Set a -> a -> Set a
addToSet s a | a `elem` s = s
             | otherwise = a : s

mkSet :: Eq a => [a] -> Set a
mkSet lst = foldl addToSet [] lst

isInSet :: Eq a => Set a -> a -> Bool
isInSet [] _ = False
isInSet [a] b = a == b
isInSet (x:xs) b | x == b = True
                 | otherwise = isInSet xs b

subset :: Eq a => Set a -> Set a -> Bool
subset sub super = and [ isInSet super x | x <- sub  ]

setEqual :: Eq a => Set a -> Set a -> Bool
setEqual a b = subset a b && subset b a

-- instance (Eq a) => Eq (Set a) where
--   a == b = subset a b && subset b a

setProd :: Set a -> Set a -> [(a,a)]
setProd a b = [ (ai,bj) | ai <- a
                        , bj <- b
                        ]

\end{minted}


\zzz{Prev Exam: Run Length Encoding}
\begin{minted}[breaklines]{haskell}
import Parsing
import Data.Char

q4 = do 
  d <- sat isUpper
  e <- char (toLower d)
  f <- many item
  return [d,e]

ones = (map (\_ -> 1) [1..])

myRLE [] = []
myRLE ls = myhelper (zip ones ls)

myhelper [(n,c)] =  [(n,c)] 
myhelper ((n,c):(m,d):rest)
  | (d == c)  = myhelper (((n+m),c):rest)
  | otherwise = (n,c):myhelper ((m,d):rest)
\end{minted}

\zzz{Rock Paper Scissors}
\begin{minted}[breaklines]{haskell}
data RPS = Rock | Paper | Scissors
  deriving (Eq, Show)

rps :: RPS -> RPS -> Int
rps a b | a == b = 0
rps Rock     Scissors = 1
rps Paper    Rock     = 1
rps Scissors Paper    = 1
rps _        _        = 2

rps2 :: RPS -> RPS -> Int
rps2 a b =
  if a == b then 0 else case (a,b) of
    (Rock,     Scissors) -> 1
    (Paper,    Rock)     -> 1
    (Scissors, Paper)    -> 1
    _ -> 2

\end{minted}

\zzz{99 problems}
\begin{minted}[breaklines]{haskell}
-- 9. pack consecutive duplicates into sublists
pack (x:xs) = let (first,rest) = span (==x) xs
               in (x:first) : pack rest
pack [] = []
-- example:
pack [1,2,3,2,2,3] == [[1,1],[2],[3],[2,2],[3]]
\end{minted}



% \end{outline}
% \end{multicols}

% \setlength{\columnseprule}{0.2pt}
% \newlist{longenum}{itemize}{5}
% \setlist[longenum,1]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\bullet$}
% \setlist[longenum,2]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\ast$}
% \setlist[longenum,3]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=-}
% \setlist[longenum,4]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=>}
% \setlist[longenum,5]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=@}
% \begin{outline}[longenum]

% \AtBeginEnvironment{minted}{ \fontsize{9}{9}\selectfont }
% \newcommand{\upspace}{\vspace{-0.8px}\linespread{0}}
% % section titles
% % makes second-level itemize bullets instead of dashes
% \renewcommand\labelitemii{\labelitemi}
% % redefine the sub-headings to inject our space-saver
% \let\oldOne\1\let\oldTwo\2\let\oldThree\3\let\oldFour\4
% \newcommand{\zzz}[1]{\noindent\0\noindent {\textbf{#1:}} \upspace}
% \renewcommand{\1}{\upspace \oldOne   \hspace{-6px}}
% \renewcommand{\2}{\upspace \oldTwo   \hspace{-6px}}
% \renewcommand{\3}{\upspace \oldThree \hspace{-6px}}
% \renewcommand{\4}{\upspace \oldFour  \hspace{-6px}}

\zzz{{\Huge Java}}


\zzz{Inheritance and Virtual Methods}
  \1 TODO

\zzz{Generics}
  \1 TODO
\0\begin{minted}[breaklines]{java}
import java.lang.*;

class GenericWildcards {
  
  // T is the binding of the generic parameter
  private static class GenericBox<T> {
    // it is optional, but we need it if we want to do things with that type
    public T t;
    public GenericBox(T t) { this.t = t; }
  }

  private static class NumberBox<T extends Number> {
    public T t;
    public NumberBox(T t) { this.t = t; } 
  }

  public static void printBox(GenericBox<?> b) {
    // here we use the ? wildcard with no type binding because we don't need to do things with that type specifically
    System.out.println(b.t);
  }

  // method generic goes before return type
  public static <T> void printWithParameter(GenericBox<T> b) {
    System.out.println(b.t);
  }

  public static void main(String[] args) {
    // this is using raw types, generally considered bad
    GenericBox rawBox = new GenericBox("asdf1"); // compiler warnings
    // this cast is ok because raw types hold java.lang.Object
    Object o1 = rawBox.t;
    // this causes no warnings for same reason as assignment above doesn't
    printBox(rawBox);
    

    // this is just using an unknown type, java says it's fine
    GenericBox<?> unknownBox = new GenericBox<>("asdf2");
    // this is also OK because <?> explicitly makes the generic parameter as java.lang.Object
    Object o2 = unknownBox.t;
    printBox(unknownBox);

    GenericBox<String> stringBox = new GenericBox<>("asdf3");
    // the type parameter above allows Java to infer that this cast is safe
    String s = stringBox.t;
    System.out.println(s);
    // must specify type between class access and method name (works the same for instance methods too)
    GenericWildcards.<String>printWithParameter(stringBox);

    ////////////////////

    // correct stuff works like expected
    NumberBox<Integer> nb1 = new NumberBox<>(5);
    System.out.println(nb1.t + 1);
    //
    // this will fail to even allow NumberBox<String> because that type doesn't work
    // NumberBox<String> sb1 = new NumberBox<>("asdf");
    // 
    // this will fail because the inferred type of NumberBox<>("asdf") is NumberBox<String>, which isn't allowed
    // NumberBox<?> sb1 = new NumberBox<>("asdf");

  }

}
\end{minted}


\zzz{Locks: \texttt{ReentrantLock} and \texttt{Condition}}

\begin{minted}{java}
import java.util.concurrent.locks.ReentrantLock;
\end{minted}
  \1 \java{ReentrantLock}: basically a mutex
  \1 \java{ReentrantLock.lock()}: acquire the lock (blocking)
    \2 does \textbf{not} throw \java{InterruptedException}
  \1 \java{ReentrantLock.unlock()}: release the lock
    \2 does \textbf{not} throw \java{InterruptedException}
    \2 you should always wrap your locking code in a \java{try{}} block (including the call to \java{lock()} itself) and put the call to \java{unlock()} in a \java{finally{}} block.
    \\This way, \java{unlock()} gets called no matter any exception

\0
\begin{minted}{java}
import java.util.concurrent.locks.Condition;
\end{minted}
  \1 created from a lock, allows one thread to send a message to another thread
    \2 create form lock instance using \java{lock.newCondition()}
  \1 \java{await()}: release this lock and wait for the condition to be signaled.
    \\ When the signal happens, \java{await()} will automatically re-acquire the lock before returning
    \\ (this means you will still have to unlock manually)
    \2 you can only \java{await()} when you are holding the lock, and when it returns, you still have the lock, so it acts like you never unlocked it
    \2 \textbf{does} throw \java{InterruptedException}
  \1 \java{signal()}: wake up a single thread that is waiting on the condition
    \2 must be holding lock to signal it's condition
    \2 must manually release lock before other thread will return from \java{await()} (because the other thread must also acquire the lock)
    \2 does \textbf{not} throw \java{InterruptedException}
  \1 \java{signalAll()}: similar to \java{signal()} except that every thread is woken up
    \2 still only one thread will be able to use the lock-protected resource at a time, because locks
    \2 does \textbf{not} throw \java{InterruptedException}
\0
\begin{minted}{java}
import java.lang.*;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
public class Main2 {
  public static class Counter {
    public int count = 0;
    public ReentrantLock lock;
    public Condition updated;
    public Counter() {
      this.lock = new ReentrantLock();
      this.updated = lock.newCondition();
    }
  }
  public static class CounterThread implements Runnable {
    private Counter counter;
    public CounterThread(Counter c) {counter = c;}
    @Override
    public void run() {
      while (true) {
        try {
          counter.lock.lock();
          counter.count += 1;
          System.out.println(counter.count);
          counter.updated.signalAll();
        } 
        // lock() does not throw InterruptedException
        // catch (InterruptedException e) {}
        finally {counter.lock.unlock();}
        
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {}
      }
    }
  }

  public static class IntervalPrinter implements Runnable {
    private Counter counter;
    private int mod;
    private String message;
    public IntervalPrinter(Counter c, int mod, String msg) {
      counter = c;
      this.mod = mod;
      message = msg;
    }
    @Override
    public void run() {
      while (true) {
        int val = 0;
        try {
          counter.lock.lock();
          counter.updated.await();
          val = counter.count;
        } 
        catch (InterruptedException e) {}
        finally {counter.lock.unlock();}

        if (val % mod == 0) {
          System.out.println(message);
        }
      }
    }
  }

  public static void main(String []args) {
    Counter c = new Counter();
    new Thread(new IntervalPrinter(c,3,"fizz")).start();
    new Thread(new IntervalPrinter(c,5,"buzz")).start();
    new Thread(new CounterThread(c)).start();
  }
}
\end{minted}


\zzz{{\large Reflection}}

\zzz{\java{java.lang.Class<T>}}
  \1 allows you to reflect on class \java{T}
  \1 \java{toString()} returns class declaration (more or less)
  \1 \java{getSimpleName()} returns just the name part of it
    \2 \java{Main.class.getSimpleName()} $\rightarrow$ \java{"Main"}
  \1 to get:
    \2 \java{Class<?> c = SomeClassName.class;}
    \2 \java{Class<?> c = someObjectInstance.getClass();}
    \2 \java{Class<?> c = Class.forName("SomeClassName");}
      \3 throws \java{ClassNotFoundException}
  \1 \java{Method[] getMethods()}
    \2 all public member methods, including those inherited from super-classes and implemented in interfaces
  \1 \java{Method[] getDeclaredMethods()}
    \2 excludes inherited methods, includes any that are declared in class regardless of public, private, static, etc...
  \1 \java{Constructor<T> getConstructor(Class<?>... pt)}
    \2 get a constructor for \java{T} that matches parameter types \java{Class<?>... pt}
    \2 throws \java{NoSuchMethodException} if there is no constructor matching those parameter types
  \1 \java{T newInstance()}
    \2 create a new instance of \java{T} using the default constructor
  \1 TODO use \java{Constructor} class to create class using non-default constructor
  \1 TODO fields

\zzz{\java{java.lang.reflect.Method}}
  \1 \java{String toString()} $\rightarrow$ method prototype as string
    \2 includes modifiers, method name, parameters, etc...
  \1 \java{String getName()} $\rightarrow$ name of method as string
  \1 \java{int getModifiers()} $\rightarrow$ \java{int} representing modifiers
    \2 use \java{java.lang.reflect.Modifier} static methods to check:
    \\ \java{Modifier.isStatic(m.getModifiers())}
  \1 \java{Class<?>[] getParameterTypes()} $\rightarrow$ types of parameters of method
    \2 if no parameters, returns empty array
    \2 does not include implicit \java{this} parameter for instance methods
  \1 \java{Type[] getGenericParameterTypes()}: same, but returns a \java{Type} instance that accurately represents the generic info from the actual source
  \1 \java{Class<?> getReturnType()}: get the return type
    \2 if it's void, it returns a void type
  \1 \java{Object invoke(Object obj, Object... args)}
    \2 invoke a method on an object. Subject to virtual method lookup
    \2 if the method is static, \java{obj} may be null
    \2 if the method returns a primitive type, it is wrapped; if void, returns null
    \2 throws \java{IllegalAccessException} if you can't run that method because it's private or something
    \2 if target method throws, it throws \java{InvocationTargetException} wrapping whatever was thrown


\end{outline}
\end{multicols}
\end{document}
