% # (c) Copyright 2017 Josh Wright
\documentclass{article}
\usepackage{mathrsfs,amsmath,amsthm,latexsym,paralist}
\usepackage{mathtools} 
\usepackage{bm} 
\usepackage{listings}
\usepackage{amssymb}   % for \varnothing, \therefore
\usepackage{centernot} % for \centernot
\usepackage{geometry}  % for margins
\usepackage{outlines}  % for outline
\usepackage{paralist}  % for compactitem, compactenum
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{minted}
\usepackage{hyperref}
\hypersetup{
  pdftitle={CSCE 314 Reference Sheet},
  pdfauthor={Josh Wright},
  pdfsubject={CSCE 314},
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=1,
  colorlinks=true,
  pdfstartview=Fit,
  pdfpagemode=UseOutlines,
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,      
  urlcolor=cyan,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% paper size, orientation, margins %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % good for on screen-only viewing
% \def \columncount {2}
% \geometry{letterpaper, landscape, margin=0.25in}
% good for printing
\def \columncount {2}
\geometry{letterpaper, portrait, margin=0.375in}


% makes second-level itemize bullets instead of dashes
% \renewcommand\labelitemi{\cdot}
\renewcommand\labelitemi{\hspace{-1in}\tiny$\bullet$}
\renewcommand\labelitemii{\labelitemi}


\newcommand{\p}{\partial}
\newcommand{\ang}[1]{\left\langle #1 \right\rangle}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\prt}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\grad}{\nabla}
\newcommand{\vrt}[1]{\rotatebox{90}{#1}}
\newcommand{\vrta}[2]{\rotatebox{90}{#1} \rotatebox{90}{#2}}
\newcommand{\vrtb}[3]{\rotatebox{90}{#1} \rotatebox{90}{#2} \rotatebox{90}{#3}}
\newcommand{\vrtc}[4]{\rotatebox{90}{#1} \rotatebox{90}{#2} \rotatebox{90}{#3} \rotatebox{90}{#4}}

\newcommand{\remove}[1]{}
% \newcommand{\remove}[1]{#1}

\newcommand{\tabletextsize}{\large}


% \setlength{\parindent}{0em}
% \setdefaultleftmargin{0em}{0em}{}{}


\begin{document}
\allowdisplaybreaks
% \large
% \Large
% asterisk makes multicols finish one column before going onto the next
\begin{multicols*}{\columncount}
\setlength{\columnseprule}{0.2pt}
\newlist{longenum}{itemize}{5}
\setlist[longenum,1]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\bullet$}
\setlist[longenum,2]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=$\ast$}
\setlist[longenum,3]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=-}
\setlist[longenum,4]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=>}
\setlist[longenum,5]{nosep,leftmargin=0.2cm,labelwidth=0px,align=left,label=@}
\begin{outline}[longenum]

\AtBeginEnvironment{minted}{
  \fontsize{9}{9}\selectfont
}

%%%%%%%%%%%%%%%%%%%%
%% spacing config %%
%%%%%%%%%%%%%%%%%%%%
% just in case I need even more space
\newcommand{\upspace}{\vspace{-0.8px}\linespread{0}}
% section titles
% makes second-level itemize bullets instead of dashes
\renewcommand\labelitemii{\labelitemi}
% redefine the sub-headings to inject our space-saver
\let\oldOne\1\let\oldTwo\2\let\oldThree\3\let\oldFour\4
\newcommand{\zzz}[1]{\noindent\0\noindent {\textbf{#1:}} \upspace}
\renewcommand{\1}{\upspace \oldOne   \hspace{-6px}}
\renewcommand{\2}{\upspace \oldTwo   \hspace{-6px}}
\renewcommand{\3}{\upspace \oldThree \hspace{-6px}}
\renewcommand{\4}{\upspace \oldFour  \hspace{-6px}}
% super-dense mode:
% \renewcommand{\1}{\upspace $\bullet$\hspace{-0.5em} }
% \renewcommand{\2}{\upspace $\bullet\bullet$\hspace{-0.5em} }
% \renewcommand{\3}{\upspace $\bullet\bullet\bullet$\hspace{-0.5em} }
% \renewcommand{\4}{\upspace $\bullet\bullet\bullet\bullet$\hspace{-0.5em} }

% \newcommand{\zzz}[1]{{\noindent\textbf{#1:}}}
% \renewcommand{\1}{$\bullet$}
% \renewcommand{\2}{$\bullet$}
% \renewcommand{\3}{$\bullet$}
% \renewcommand{\4}{$\bullet$}

\noindent
\textbf{CSCE 314 Reference Sheet} \hfill Last Updated: \today \hfill \textcopyright \space Josh Wright 2017
% \vspace{-0.4cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% real content starts here %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\zzz{General}
  \1 \texttt{newtype Parser a = P (String -> [(a,String)])}
  \1 Predicate: a function that takes one argument and returns a boolean
    \2 if \texttt{pred x == True} then \texttt{x} satisfies predicate \texttt{pred}
  \1 function composition:
\begin{minted}{haskell}
-- the . operator composes functions:
(f . g) x == f (g x)
\end{minted}

\0 useful library functions:
\begin{minted}{haskell}
-- Data.List
nubBy :: (a -> a -> Bool) -> [a] -> [a]
nubBy pred xs = -- unique elements only from xs as 
                -- determined by pred
nub :: Eq a => [a] -> [a]
nub xs = nubBy (==) a -- unique elements from xs
-- 
words :: String -> [String]
words xs =  -- list of whitespace-separated 
            -- words from xs
--
-- concatenate container of lists
concat :: Foldable t => t [a] -> [a]
-- or for list-of-lists specifically:
concat :: [[a]] -> [a]
concat xs = foldl (++) [] xs
--
-- like concat, but use a function to get the inner lists
concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f xs =  foldr ((++) . f) [] xs
-- 
-- get the longest prefix of xs for which pred is true
-- and also return the rest of the list
span :: (a -> Bool) -> [a] -> ([a], [a])
span pred xs = (takeWhile pred xs, dropWhile pred xs)
-- 
-- repeat a = infinite list of a
repeat :: a -> [a]
repeat x = map (\_ -> x) [1..]
repeat x = [ x | _ <- [1..] ]
-- replicate n a = list of length n repeating a
replicate :: Int -> a -> [a]
replicate n x = map (\_ -> x) [1..n]
replicate n x = [ x | _ <- [1..n] ]
--
-- folds (works on any foldable, not just lists)
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z [a,b,c] = a `f` (b `f`  (c `f` z))
foldr f z [a,b,c] = f a $ f b $ f c z
-- combines into z from right to left
-- can potentially work on an empty list if one of the
-- folds does not evaluate it's second argument
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z [a,b,c] = ((z `f` a) `f` b) `f` c
foldl f z [a,b,c] = f (f (f z a) b) c
-- evaluates from right to left
-- will not work on infinite list because it must start at 
-- the end of the list
-- 
-- these are the same as above, except they take the first 
-- two elements for the first application of f
foldr1 :: (a -> a -> a) -> [a] -> a
foldl1 :: (a -> a -> a) -> [a] -> a                                                                                                                                                                                                                                                                                                                                                                       =
\end{minted}


\zzz{Parsing.hs}
  \1 \texttt{sat :: (Char -> Bool) -> Parser Char}
    \2 returns a character if that character satisfies the predicate
  \1 \texttt{digit, letter, alphanum :: Parser Char}
    \2 parses a digit, letter, or alpha-numeric letter respectively
  \1 \texttt{char :: Char -> Parser Char}
    \2 \texttt{char `a'} parses exactly the character \texttt{`a'}
  \1 \texttt{item :: Parser Char}
    \2 parses any character
  \1 similar to above:
    \texttt{
      digit
      letter
      alphanum
      lower
      upper
      string
    }
  \1 \texttt{many :: Parser a -> Parser [a]}
    \2 parses 0 or more instances of \texttt{a} and collects them into a list
  \1 \texttt{many1 :: Parser a -> Parser [a]}
    \2 same as \texttt{many}, but 
  \1 \texttt{(+++)} choice: 
    \2 parse first argument if possible, else parse second argument
    \2 first successfully parsed argument is returned
\begin{minted}{haskell}
(+++) :: Parser a -> Parser a -> Parser a
p +++ q =  P (\inp -> case parse p inp of
                  []        -> parse q inp
                  [(v,out)] -> [(v,out)])
\end{minted}
  \1 \texttt{((>>=))} sequential composition
    \2 \texttt{a >>= b} unboxes monad \texttt{a} into an output \texttt{a0} and then unboxes monad \texttt{b} with input \texttt{a0}
\begin{minted}{haskell}
type Parser a = String -> [(a, String)]
-- implementation for in-class mostly-complete
-- parser `monads'
(>>=) :: Parser a -> (a -> Parser b) -> Parser b
(>>=) p1 p2 = \inp -> case parse p1 inp of
      []  ->  []
      [(v, out)] -> parse (p2 v) out
                                                                                                                                                                                                                                                                                                                                                                       =
\end{minted}
  \2 usage:
\begin{minted}{haskell}
doubleDigit :: Parser [Char]
doubleDigit =
  digit >>= \a ->
  digit >>= \b ->
  return [a,b]
-- is equivalent to
doubleDigit' :: Parser [Char]
doubleDigit' = do
  a <- digit
  b <- digit
  return [a,b]
\end{minted}
  \2 \texttt{(>>)} is the same except that it discards the result of the first monad (thus it has signature \texttt{(>>) :: Parser a -> Parser b -> Parser b})

\zzz{Parsing Examples}
  \1 bind and lambda method of parsing:
    \2 parse a number:
  \1 parse arithmetic expressions using do syntax:
\begin{minted}{haskell}
expr :: Parser Int
expr  = do t <- term
           do {char '+'
              ;e <- expr
              ;return (t + e)
              }
            +++ return t

term :: Parser Int
term  = do f <- factor
           do char '*'
              t <- term
              return (f * t)
            +++ return f

factor :: Parser Int
factor  = do d <- digit
             return (digitToInt d)
           +++ do char '('
                  e <- expr
                  char ')'
                  return e

eval   :: String -> Int
eval xs = fst (head (parse expr xs))
\end{minted}

\zzz{Trees}
  \1 represent either a leaf node or some kind of internal node
  \1 arithmetic tree declaration:
\begin{minted}{haskell}
data Expr = Val Int
          | Neg Expr 
          | Add Expr Expr 
          | Mul Expr Expr
\end{minted}
  \1 how to fold over a tree:
\begin{minted}{haskell}
-- exprFold  valF        negF      addF     
exprFold :: (Int->b) -> (b->b) -> (b->b->b) ->
-- mulF        input   output
  (b->b->b) -> Expr -> b
exprFold valF _ _ _ (Val i) = valF i
exprFold valF negF addF mulF (Neg e) 
  = negF  (exprFold valF negF addF mulF e)
exprFold valF negF addF mulF (Add s1 s2) 
  = addF  (exprFold valF negF addF mulF s1)
          (exprFold valF negF addF mulF s2)
exprFold valF negF addF mulF (Mul s1 s2) 
  = mulF  (exprFold valF negF addF mulF s1) 
          (exprFold valF negF addF mulF s2)
\end{minted}
    \2 basically, just collect values into some type \texttt{b} and use supplied functions at each node to fold into single value
    \2 useful for evaluating simple things like:
\begin{minted}{haskell}
-- evaluate an expression
evalExpr'    = exprFold id (\x -> 0 - x) (+) (*)
id --  integers map to integers
(\x -> 0 - x) -- negation
-- everything else is just simple numeric operators
-- 
-- count leaves in a tree
countLeaves' = exprFold (\_ -> 1) id (+) (+)
(\_ -> 1) -- leaf integer node is one node
id -- negation node has only one child, pass on count
(+) (+) -- nodes with two children: add number 
        -- of leaf grandchildren
\end{minted}


\zzz{HW2: Water Gates}
\begin{minted}{haskell}


waterGate :: Int -> Int
waterGate n =
 length -- number of True's
 $ filter id -- filter just True's
 $ waterGate' n initial -- initial call to helper
 where
  -- start with all gates closed
  initial = replicate n False
  --
  -- flip states
  waterGate' 1 state = map not state 
    -- base case: flip every state
  waterGate' n state = flip n $ waterGate' (n-1) state
  -- otherwise, first get the state for (n-1) and then 
  -- flip every nth state
  --
  -- flip every nth gate
  flip :: Int -> [Bool] -> [Bool]
  flip 1 xs = map not xs -- flip every gate
  -- flip only gates which index are multiples of n
  flip nth xs = [ if (i `mod` nth == 0) then not x else x
                -- zip each state with it's index
                | (x,i) <- (zip xs [1..])  ]

\end{minted}

\zzz{HW2: Goldbach's Other Conjecture}
\begin{minted}{haskell}
-- check if a number is prime
primeTest :: Integer -> Bool
primeTest 1 = False
primeTest t =  and [ (gcd t i) == 1 | i <- [2..t-1]]

-- all numbers less than n that are double a square
twiceSquares :: Integer -> [Integer]
twiceSquares n = takeWhile (<n) [ 2 *x^2 | x <- [1..]]

-- list of odd numbers
oddList = map (\x -> 2*x + 1) [0..]
-- all odd numbers that are composite (not prime)
allOddComp = [ o | o <- (drop 1 oddList)
                 , not (primeTest o)     ]

-- if a number satisfies conditions for conjecture
-- method: for enough square nubmers, check if
-- n-(that number) is prime
satsConds n = or [ primeTest k | 
                  k <- map (\x->(n-x)) (twiceSquares n) ]

-- find the first number 
goldbachNum = head [ x | x <- allOddComp
                       , not (satsConds x) ]
\end{minted}


\zzz{HW4: Sets}
\begin{minted}{haskell}
type Set a = [a]

a = mkSet [1,2,3,4,5]
b = mkSet [1,2,3]


addToSet :: Eq a => Set a -> a -> Set a
addToSet s a | a `elem` s = s
             | otherwise = a : s

mkSet :: Eq a => [a] -> Set a
mkSet lst = foldl addToSet [] lst

isInSet :: Eq a => Set a -> a -> Bool
isInSet [] _ = False
isInSet [a] b = a == b
isInSet (x:xs) b | x == b = True
                 | otherwise = isInSet xs b

subset :: Eq a => Set a -> Set a -> Bool
subset sub super = and [ isInSet super x | x <- sub  ]

setEqual :: Eq a => Set a -> Set a -> Bool
setEqual a b = subset a b && subset b a

-- instance (Eq a) => Eq (Set a) where
--   a == b = subset a b && subset b a

setProd :: Set a -> Set a -> [(a,a)]
setProd a b = [ (ai,bj) | ai <- a
                        , bj <- b
                        ]

\end{minted}


\zzz{Prev Exam: Run Length Encoding}
\begin{minted}{haskell}
import Parsing
import Data.Char

q4 = do 
  d <- sat isUpper
  e <- char (toLower d)
  f <- many item
  return [d,e]

ones = (map (\_ -> 1) [1..])

myRLE [] = []
myRLE ls = myhelper (zip ones ls)

myhelper [(n,c)] =  [(n,c)] 
myhelper ((n,c):(m,d):rest)
  | (d == c)  = myhelper (((n+m),c):rest)
  | otherwise = (n,c):myhelper ((m,d):rest)
\end{minted}

\zzz{Rock Paper Scissors}
\begin{minted}{haskell}
data RPS = Rock | Paper | Scissors
  deriving (Eq, Show)

rps :: RPS -> RPS -> Int
rps a b | a == b = 0
rps Rock     Scissors = 1
rps Paper    Rock     = 1
rps Scissors Paper    = 1
rps _        _        = 2

rps2 :: RPS -> RPS -> Int
rps2 a b =
  if a == b then 0 else case (a,b) of
    (Rock,     Scissors) -> 1
    (Paper,    Rock)     -> 1
    (Scissors, Paper)    -> 1
    _ -> 2

\end{minted}

\zzz{99 problems}
\begin{minted}{haskell}
-- 9. pack consecutive duplicates into sublists
pack (x:xs) = let (first,rest) = span (==x) xs
               in (x:first) : pack rest
pack [] = []
-- example:
pack [1,2,3,2,2,3] == [[1,1],[2],[3],[2,2],[3]]
\end{minted}


\zzz{{\Huge Java}}


\zzz{Inheritance and Virtual Methods}
  \1 TODO


\zzz{Locks: \texttt{ReentrantLock} and \texttt{Condition}}

\begin{minted}{java}
import java.util.concurrent.locks.ReentrantLock;
\end{minted}
  \1 \verb|ReentrantLock|: basically a mutex
  \1 \verb|ReentrantLock.lock()|: acquire the lock (blocking)
    \2 does \textbf{not} throw \verb|InterruptedException|
  \1 \verb|ReentrantLock.unlock()|: release the lock
    \2 does \textbf{not} throw \verb|InterruptedException|
    \2 you should always wrap your locking code in a \verb|try{}| block (including the call to \verb|lock()| itself) and put the call to \verb|unlock()| in a \verb|finally{}| block.
    \\This way, \verb|unlock()| gets called no matter any exception

\0
\begin{minted}{java}
import java.util.concurrent.locks.Condition;
\end{minted}
  \1 created from a lock, allows one thread to send a message to another thread
    \2 create form lock instance using \verb|lock.newCondition()|
  \1 \verb|await()|: release this lock and wait for the condition to be signaled.
    \\ When the signal happens, \verb|await()| will automatically re-acquire the lock before returning
    \\ (this means you will still have to unlock manually)
    \2 you can only \verb|await()| when you are holding the lock, and when it returns, you still have the lock, so it acts like you never unlocked it
    \2 \textbf{does} throw \verb|InterruptedException|
  \1 \verb|signal()|: wake up a single thread that is waiting on the condition
    \2 must be holding lock to signal it's condition
    \2 must manually release lock before other thread will return from \verb|await()| (because the other thread must also acquire the lock)
    \2 does \textbf{not} throw \verb|InterruptedException|
  \1 \verb|signalAll()|: similar to \verb|signal()| except that every thread is woken up
    \2 still only one thread will be able to use the lock-protected resource at a time, because locks
    \2 does \textbf{not} throw \verb|InterruptedException|
\0
\begin{minted}{java}
import java.lang.*;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
public class Main2 {
  public static class Counter {
    public int count = 0;
    public ReentrantLock lock;
    public Condition updated;
    public Counter() {
      this.lock = new ReentrantLock();
      this.updated = lock.newCondition();
    }
  }
  public static class CounterThread implements Runnable {
    private Counter counter;
    public CounterThread(Counter c) {counter = c;}
    @Override
    public void run() {
      while (true) {
        try {
          counter.lock.lock();
          counter.count += 1;
          System.out.println(counter.count);
          counter.updated.signalAll();
        } 
        // lock() does not throw InterruptedException
        // catch (InterruptedException e) {}
        finally {counter.lock.unlock();}
        
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {}
      }
    }
  }

  public static class IntervalPrinter implements Runnable {
    private Counter counter;
    private int mod;
    private String message;
    public IntervalPrinter(Counter c, int mod, String msg) {
      counter = c;
      this.mod = mod;
      message = msg;
    }
    @Override
    public void run() {
      while (true) {
        int val = 0;
        try {
          counter.lock.lock();
          counter.updated.await();
          val = counter.count;
        } 
        catch (InterruptedException e) {}
        finally {counter.lock.unlock();}

        if (val % mod == 0) {
          System.out.println(message);
        }
      }
    }
  }

  public static void main(String []args) {
    Counter c = new Counter();
    new Thread(new IntervalPrinter(c,3,"fizz")).start();
    new Thread(new IntervalPrinter(c,5,"buzz")).start();
    new Thread(new CounterThread(c)).start();
  }
}
\end{minted}


\zzz{Reflection}
  \1 TODO


\end{outline}
\end{multicols*}
\end{document}
